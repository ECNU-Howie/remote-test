我生于清朝，原是奴隶出身，不同25岁的青年，一生下来，就是中华民国的主子。

任凭你爱排场的学者们怎样铺张，修史时候设些什么“汉族发祥时代”“汉族发达时代”“汉族中兴时代”的好题目，好意诚然是可感的，但措辞太绕湾子了。有更其直截了当的说法在这里—— 一，想做奴隶而不得的时代；二，暂时做稳了奴隶的时代。

## Hadoop

### 入门

1）端口号（3.X）

8020：namenode内部通信端口

9870：namenode的http UI

8088：MR执行情况

19888：historyserver



2）常用配置(3.X)

core-site.xml	hdfs-site.xml	mapred-site.xml	yarn-site.xml	workers



### HDFS

##### HDFS文件块大小

![image-20230308100908519](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230308100908519.png)





==有一个问题==是：kafka中说是顺序读写，所以即使是机械硬盘速度也能够达到600M/s，那么HDFS不是顺序读写吗，它不是也是追加写吗？

![image-20230308101140586](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230308101140586.png)

##### HDFS读写流程

![image-20230309094706258](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230309094706258.png)









![image-20230320145722682](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320145722682.png)



##### NameNode工作机制

记住一点：NN和2NN的主要区别：edits_inprogress只在NN里存在。



![image-20230309101358057](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230309101358057.png)



##### DataNode

![image-20230320145803722](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320145803722.png)











1）笔试题：HDFS读写流程	有没有朋友（拍照发群里）

2）面试题：小文件

- 小文件的危害

  - 存储

  

  

  - 计算





- 小文件怎么解决



### MR

##### MapReduce核心思想

![image-20230310101009038](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230310101009038.png)



##### 切片与MapTask并行度决定机制

数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。数据切片是MapReduce程序计算输入数据的单位，一个切片会对应启动一个MapTask。

![image-20230310101248018](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230310101248018.png)

#### FileInputFormat实现类

##### TextInputFormat

框架默认的TextInputFormat切片机制是对任务按文件规划切片，不管文件多小，都会是一个单独的切片，都会交给一个MapTask

##### CombineTextInputFormat

优化产生大量的MapTask。处理计算时的小文件问题

生成切片过程包括：虚拟存储过程和切片过程二部分。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317113115398.png" alt="image-20230317113115398"  />

#### MR工作流程

![image-20230317115922694](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317115922694.png)



![image-20230317115941891](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317115941891.png)



第15步分组没用了













### yarn



## SQL

##### 小原则：

在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中

```mysql
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id ;
```

###### sql执行顺序

![image-20230323171728097](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230323171728097.png)

### mysql



### hivesql

##### hive是什么？

Hive是一个Hadoop客户端，用于将**HQL（Hive SQL）**转化成**MapReduce程序**。

启动hiveserver2

nohup hive --service hiveserver2 &

启动metastore

nuhup hive --service metastore &

脚本命令

 hiveservices.sh start

### DDL

#### 表

##### 创建表

###### ROW FORMAT & STORED AS

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230323141056172.png" alt="image-20230323141056172" style="zoom:80%;" />

ROW FORMAT 指定对每行数据进行序列化和反序列化解析的参数

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230323141332897.png" alt="image-20230323141332897" style="zoom:67%;" />

STORED AS 指定文件读写的格式

### DML



###### mr运行在本地模式

set mapreduce.framework.name=local;

### 查询

#### join连接

![image-20230323184532832](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230323184532832.png)



#### 排序



### 函数

#### UDTF

炸裂函数：UDTF（Table-Generating Functions），接收一行数据，输出一行或多行数据。

Latera View 通常与UDTF配合使用。Lateral View可以将UDTF应用到源表的每行数据，将每行数据转换为一行或多行，并将源表中每行的输出结果与该行连接起来，形成一个虚拟表。

![image-20230207160736857](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230207160736857.png)



#### 窗口函数

##### 基于行

![image-20230207202423040](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230207202423040.png)



![](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230207193817827.png)



##### 基于值

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327160321996.png" alt="image-20230327160321996" style="zoom:80%;" />

![image-20230328141531774](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328141531774.png)

##### 分区

![image-20230327161403477](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327161403477.png)



![image-20230327161714406](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327161714406.png)



##### 缺省

![image-20230327162044237](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327162044237.png)

如何理解包含order by则默认基于值range：基于值得话肯定得排序啊，要不然怎么基于值



##### 常用窗口函数

###### 聚合函数

max：最大值。

min：最小值。

sum：求和。

avg：平均值。

count：计数。

###### lead和lag（与正常思维相反）

不支持自定义窗口（要写得内容更少了）

![image-20230327163529099](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327163736842.png)

###### first_value和last_value

![image-20230327164530634](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327164530634.png)

###### 排名函数

也不支持自定义窗口

![image-20230327164849689](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327164849689.png)

##### 去重的方法

- 两个字段去重不能加括号，直接在要去重的字段钱加distinct关键字

![image-20230327212850853](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327212850853.png)

- 使用group by去重

![image-20230327212916715](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327212916715.png)

- 使用窗口函数去重

![image-20230327212946192](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230327212946192.png)







hive面试题（10件事）

## zookeeper

启动命令

zk.sh start





## Flume

### 基础梳理



### 面试题



## kafka

### 基础梳理

##### 什么是kafka？

Kafka是一个**分布式**的**基于发布/订阅模式**的==消息队列（Message Queue）==。

kafka大致分为生产者，broker，消费者

#### kafka生产者producer

- 两个线程：**main线程**，**sender线程**

- 一个线程共享变量：RecordAccumulator

- 正是由于RecordAccumulator的存在，实现了==异步发送==



![image-20230303151418144](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230303151418144.png)

##### 生产者分区

分区的原因：提高并行度

分区策略：

- 指定partition则按指定分区
- 没有指定partition，但是指定key，将key值的hashcode与该topic的分区个数partition取模得到
- 没有partition，也没有key，则按照Sticky Partition（粘性分区器），会随机选择一个分区，并尽可能一直使用该分区，待该分区的batch已满或者已完成，kafka再随机一个分区（绝对不会是上一个）进行使用.

#### kafka的broker

具体看面试大保健

![image-20230303200003241](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230303200003241.png)

#### kafka消费者

##### 消费者组初始化流程

- 消费者coordinator分区的做法与Transaction_Coordinator的做法一致。

- 消费者组内的消费者意识不到组内其他消费者的存在，需要coordinator将消费的topic情况发送给leader consumer。



![image-20230303192427186](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230303192427186.png)

### 面试题

## 采集项目

迷思：这个source为什么要配置两个broker路径，但是又不配104

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230305161101494.png" alt="image-20230305161101494" style="zoom:80%;" />

##### 时间漂移问题

在kafka到hdfs的flume source中添加一个拦截器，将json中的时间信息传入event的header里。

优化：

##### 系统数据流程图

![image-20230418194918122](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230418194918122.png)





##### 集群部署规划

![image-20230418195127937](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230418195127937.png)

##### 相关脚本

将在kafka消费flume的source中加的拦截器放到采集到kafka的flume source中

依次启动**hdfs**(myhadoop.sh start)，**zookeeper**(zk.sh)，**kafka**(kafka.sh)，kafka日志**消费的flume**(f2.sh start)

（bin/flume-ng agent -n a1 -c conf/ -f job/flume-kafkaChannel-hdfs_test.conf -Dflume.root.logger=INFO,console）

**采集flume**(f1.sh start)（bin/flume-ng agent -n a1 -c conf/ -f job/flume-tailDir-kafka_test.conf -Dflume.root.logger=INFO,console）

启动**日志数据模拟程序**：lg.sh

##### 关于shell脚本的编写

## DataX

#### 什么是DataX？

- 异构数据源离线同步工具，实现包括关系型数据库（Mysql、Oracle等）、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能

![image-20230307192530534](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230307192530534.png)

- 采用Framework+plugin架构构建

![image-20230307192545599](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230307192545599.png)

启动datax命令：python bin/datax.py job/base_province_tableMode.json

使用python程序实现自动生成对应的json文件



maxwell增量表首日全量同步+每日增量同步



##### 整体测试

清空HDFS内的数据

清空102、103的/opt/module/applog/log里面的日志数据（flume采集的）

启动整个集群相关程序cluster.sh start

102启动日志生成脚本lg.sh

102启动首日全量同步脚本 mysql_to_kafka_inc_init.sh all

102启动每日全量同步脚本 mysql_to_hdfs_full.sh all 2020-06-14

102产生数据库业务数据：在/opt/module/db_log 使用命令：java -jar gmal***

## scala:一门完全面向对象的函数式编程语言

函数式编程

java还遗留有基本数据类型，不是完全面向对象的。

![image-20230309134017640](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230309134017640.png)

- scala中的object=java中的静态类

- java中的数组其实没有类型，这里的String是数组元素的类型

​		String []  str = new String()

​		java中的集合是有类型的，比如ArrayList，HashMap等。

​		scala的数组是有类型的

##### 字节码解析

有时候看源码我们并不能完全参透程序是如何运行的，需要编译成字节码然后反编译查看程序运行

比如静态变量实际上是在后面隐藏了一个静态代码块

#### 变量

![image-20230309185613655](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230309185613655.png)

##### var和val的区别

![image-20230320145926594](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320145926594.png)



##### 至简原则

![image-20230309191657218](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230309191657218.png)

#### 字符串

scala中没有字符串，使用的java的字符串

类似于python的字符串格式化

##### 传值字符串

##### 插值字符串

##### 多行字符串，主要用于SQL和JSON



#### 数据类型

![image-20230310115245140](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310115245140.png)

##### 自动（隐式）类型转换（要符合树的逻辑）

![image-20230310115105369](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310115105369.png)

##### 也可以显示类型转换

![image-20230310135748652](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310135748652.png)

##### 关于char是否能够转成int

根据规则是不可以的，但是常量除外

![image-20230310140140967](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310140140967.png)

#### 运算符

##### 比较运算符

scala的==等同于java中的非空equals（）方法，equals发挥作用的前提是这个class重写了equals方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310142806316.png" alt="image-20230310142806316" style="zoom:80%;" />

反编译可以看到源码实现

![image-20230310142644191](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310142644191.png)

##### scala为什么没有自增++自减--运算符

（用+=来代替）

避免歧义，请看java里面的++语法

源码如下：

![image-20230310163033464](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230310163033464.png)

编译之后反编译：

![image-20230310163215774](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310163215774.png)

##### 运算符的本质

真正的一切皆是对象

运算符就是对象的方法

![image-20230310164721428](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230310164721428.png)

##### if-else运算符有返回值

![image-20230310192850443](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310192850443.png)

#### for循环

##### to,until,Range

![image-20230310201801060](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310201801060.png)

##### 循环守卫

循环守卫，即循环保护式（也称条件判断式，守卫）。**保护式为 true 则进入循环 体内部，为 false 则跳过**，类似于 continue

![image-20230310202455382](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310202455382.png)

等价于

![image-20230310202511066](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310202511066.png)

##### 循环步长

![image-20230310202751707](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310202751707.png)

##### 循环嵌套

![image-20230310203117952](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230310203117952.png)

##### 引入变量

![image-20230313120200775](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313120200775.png)





##### 循环返回值yield关键字 

![image-20230313120601318](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313120601318.png)



##### 循环中断

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313143713313.png" alt="image-20230313143713313" style="zoom:67%;" />



简单点——》

![image-20230313144229862](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313144229862.png)





<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313144321746.png" alt="image-20230313144321746" style="zoom:67%;" />



### 函数式编程

#### java中的方法与scala的函数的区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313145711440.png" alt="image-20230313145711440" style="zoom:80%;" />





##### 函数的声明与使用

![image-20230313151215986](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313151215986.png)

##### 函数与方法

function：函数

method：方法

1.函数可以声明在任意的位置，方法只能声明在类中

2.如果函数名称和方法名称相同，那么默认情况下，或调用函数。如果没有就按书，会调用方法



##### 函数的本质

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313162029565.png" alt="image-20230313162029565" style="zoom: 80%;" />



反编译后:

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313162136181.png" alt="image-20230313162136181" style="zoom:67%;" />

#### 函数参数

##### *表示可变参数

可变参数要放在最后

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313171217290.png" alt="image-20230313171217290" style="zoom:67%;" />

##### 带默认值的参数

如果要改变传参的顺序，则需要显示的传参

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313172510415.png" alt="image-20230313172510415" style="zoom:67%;" />



#### 至简原则









#### 函数对象作为变量赋值

函数就是对象：

- 对象就该有类型

- 对象就可以赋值给别人

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230313204316685.png" alt="image-20230313204316685" style="zoom: 80%;" />



##### 函数类型的简化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314102247370.png" alt="image-20230314102247370" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314102152150.png" alt="image-20230314102152150" style="zoom:80%;" />

#### 将函数对象作为参数传递

java代码

![image-20230314104402379](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314104402379.png)

Scala代码

可以省略下划线

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314104500373.png" alt="image-20230314104500373" style="zoom:80%;" />

##### 匿名函数传参

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314112403569.png" alt="image-20230314112403569" style="zoom:80%;" />



##### 简化匿名函数传参

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314114725575.png" alt="image-20230314114725575" style="zoom:80%;" />



#### 将函数对象作为返回结果返回

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314153819238.png" alt="image-20230314153819238" style="zoom:67%;" />

#### 控制抽象

抽象：不完整

抽象类：不完整的类

抽象方法：不完整的方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314173707514.png" alt="image-20230314173707514" style="zoom: 67%;" />

控制抽象：就是把代码作为参数传递

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314191342286.png" alt="image-20230314191342286" style="zoom:80%;" />

##### 控制抽象的实例

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314192014418.png" alt="image-20230314192014418" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314192154393.png" alt="image-20230314192154393" style="zoom:80%;" />

使用控制抽象实现一个while循环

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315142307290.png" alt="image-20230315142307290" style="zoom: 80%;" />













#### 闭包

不写返回值类型

按照栈来分析生命周期似乎不合理，但是由于底层特殊的编译方式，可以**实现生命周期的改变**

![image-20230314200010315](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314200010315.png)



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230314200038728.png" alt="image-20230314200038728" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406150319707.png" alt="image-20230406150319707" style="zoom:50%;" />

#### 函数柯里化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315100215211.png" alt="image-20230315100215211" style="zoom:80%;" />



柯里化与闭包

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315100438338.png" alt="image-20230315100438338" style="zoom:80%;" />

#### 递归

scala中递归函数的返回值类型不能省略（递归导致类型推断失败）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315102204334.png" alt="image-20230315102204334" style="zoom: 80%;" />



##### 栈溢出——尾递归优化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315104516134.png" alt="image-20230315104516134" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315104158062.png" alt="image-20230315104158062" style="zoom:80%;" />

反编译之后代码

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315104242897.png" alt="image-20230315104242897" style="zoom:80%;" />

##### 内存溢出——没有足够的空间分配栈空间（内存）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315105229856.png" alt="image-20230315105229856" style="zoom:80%;" />

栈的空间扩大了，意味着支持的线程数变少了，并发度下降

#### 惰性函数

为啥需要惰性函数？

很有可能代码并不需要立即执行，如果立即执行会有大量内存浪费，那么我们将这类函数要用到的时候再调用。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315110423540.png" alt="image-20230315110423540" style="zoom:80%;" />

### 面向对象编程

#### 包

<img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230315145159768.png" alt="image-20230315145159768" style="zoom:80%;" />





<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315145546404.png" alt="image-20230315145546404" style="zoom:80%;" />



![image-20230315151816456](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315151816456.png)

##### scala的包管理

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315155150849.png" alt="image-20230315155150849" style="zoom: 80%;" />







<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315160108198.png" alt="image-20230315160108198" style="zoom:80%;" />



有的时候不同包下同名的类太多，起个别名好区分。

<img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20230315155928070.png" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315161341088.png" alt="image-20230315161341088" style="zoom:80%;" />



#### 类

##### java的class和Scala的object的渊源



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315164751784.png" alt="image-20230315164751784" style="zoom:80%;" />



一个object文件会编译成两个.class文件

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315164606367.png" alt="image-20230315164606367" style="zoom: 80%;" />



伴生类、伴生对象



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315171000925.png" alt="image-20230315171000925" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315171109362.png" alt="image-20230315171109362" style="zoom:80%;" />

##### java中的class和scala的class的书写规范

Java：

![image-20230315170630660](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315170630660.png)

scala的公共类不需要public标示，编译后反编译查看自动会变成public

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315171321836.png" alt="image-20230315171321836" style="zoom: 67%;" />



##### 静态与成员——线程里sleep和wait的区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315191308408.png" alt="image-20230315191308408" style="zoom:67%;" />

#### 属性field

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315193650346.png" alt="image-20230315193650346" style="zoom:80%;" />

##### 反编译深入字节码文件

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315194655948.png" alt="image-20230315194655948" style="zoom:80%;" />

如果我们在变量定义前添加private关键字，编译后则会将get，set方法也设为私有。

##### Scala Bean——添加注解

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315194758302.png" alt="image-20230315194758302" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315194825286.png" alt="image-20230315194825286" style="zoom:80%;" />



#### 访问权限

##### java的权限管理

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230315151630383.png" alt="image-20230315151630383" style="zoom: 67%;" />



##### Scala访问权限

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316115337999.png" alt="image-20230316115337999" style="zoom: 80%;" />



##### 深入理解java的权限——clone方法

点表示从属关系，test.AAA的对象不是clone（）方法的调用者

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316110447884.png" alt="image-20230316110447884" style="zoom: 67%;" />



实际的调用者：本类test.TestAccess的main方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316110749931.png" alt="image-20230316110749931" style="zoom: 67%;" />

实例化AAA的时候，其父类Object也会实例化。虽然类有继承关系，但是实例化以后，实例化的对象就没有继承关系。

由于TestAccess与AAA的父类Object没有继承关系，所以通过TestAccess的main方法调用AAA的父类Object的clone( )方法是无法实现的

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316112048311.png" alt="image-20230316112048311" style="zoom:67%;" />



重写AAA的clone方法，提供者AAA和调用者TestAccess同包。可以调用。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316112835429.png" alt="image-20230316112835429" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316113230405.png" alt="image-20230316113230405" style="zoom:67%;" />





#### 方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316123130808.png" alt="image-20230316123130808" style="zoom:80%;" />

关于方法method和函数function：

Scala内部会将函数function进行调整，方法method则会保留成原来的java方法。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316122324913.png" alt="image-20230316122324913" style="zoom:67%;" />

##### 方法的重载







##### 方法的重写

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316125217329.png" alt="image-20230316125217329" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316125140386.png" alt="image-20230316125140386" style="zoom:80%;" />

##### 动态绑定

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316125331212.png" alt="image-20230316125331212" style="zoom:80%;" />

动态绑定与属性无关，属性在哪里声明，在哪里使用

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316125430869.png" alt="image-20230316125430869" style="zoom:80%;" />



![image-20230316134824025](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316134824025.png)



#### 实例化

##### 实例化的途径

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316145842731.png" alt="image-20230316145842731" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316150015013.png" alt="image-20230316150015013" style="zoom:80%;" />

##### 构造方法



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316154858927.png" alt="image-20230316154858927" style="zoom:80%;" />



##### 构造方法传参

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316160127925.png" alt="image-20230316160127925" style="zoom:67%;" />

构造函数传参给属性



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316163904012.png" alt="image-20230316163904012" style="zoom:80%;" />

##### 构造方法重载

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316162259979.png" alt="image-20230316162259979" style="zoom: 67%;" />

补充：多个构造方法在调用时，需要提前声明

（错误的写法）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230316162832671.png" alt="image-20230316162832671" style="zoom:67%;" />



##### 导入对象

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317122945664.png" alt="image-20230317122945664" style="zoom:80%;" />

#### 继承

多继承的钻石问题

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317152738886.png" alt="image-20230317152738886" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317152701928.png" alt="image-20230317152701928" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317153117392.png" alt="image-20230317153117392" style="zoom:80%;" />

构造方法私有化后如何构建对象

![image-20230317153854667](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317153854667.png)



![image-20230317154406239](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317154406239.png)

#### 封装

封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行访问。

#### 抽象abstract



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317160948593.png" alt="image-20230317160948593" style="zoom:80%;" />

补充抽象方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317161505370.png" alt="image-20230317161505370" style="zoom:80%;" />

##### 抽象属性

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317162945454.png" alt="image-20230317162945454" style="zoom:80%;" />

反编译

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317163015134.png" alt="image-20230317163015134" style="zoom:80%;" />

可变变量（var）不能被重写

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317163351445.png" alt="image-20230317163351445" style="zoom:80%;" />

#### 单例对象object

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317164729403.png" alt="image-20230317164729403" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317164852119.png" alt="image-20230317164852119" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317164714193.png" alt="image-20230317164714193" style="zoom:80%;" />



#### 特质trait—接口interface

##### 什么是特质

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317171326425.png" alt="image-20230317171326425" style="zoom:80%;" />

问题？为什么存在父类用with，没有父类用extends

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317171307927.png" alt="image-20230317171307927" style="zoom:80%;" />

特质的本质就是interface

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320132434965.png" alt="image-20230320132434965" style="zoom:80%;" />



##### 特质（trait）是接口和抽象类的结合体

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317173137656.png" alt="image-20230317173137656" style="zoom:80%;" />

反编译

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317172936168.png" alt="image-20230317172936168" style="zoom:80%;" />



##### 容易出现多继承错误

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317173219388.png" alt="image-20230317173219388" style="zoom:80%;" />

##### 动态混入



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317192422802.png" alt="image-20230317192422802" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317192508382.png" alt="image-20230317192508382" style="zoom:80%;" />

##### 特征的初始化顺序

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317193500702.png" alt="image-20230317193500702" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317193531798.png" alt="image-20230317193531798" style="zoom:80%;" />

初始化顺序为，2、3、1、4

##### 功能执行顺序

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317210049815.png" alt="image-20230317210049815" style="zoom:80%;" />

```scala
package com.atguigu.scala.chapter06

object Scala14_Object_Trait_3 {
  def main(args: Array[String]): Unit = {
    val mysql = new MySQL
    mysql.operateDate()
  }

  trait Operate {
    def operateDate(): Unit = {
      println("数据处理")
    }
  }

  trait DateBase extends Operate {
    override def operateDate(): Unit = {
      print("向数据库中")
      super.operateDate()
    }
  }

  trait Log extends Operate {
    override def operateDate(): Unit = {
      print("向日志文件中")
      super.operateDate()
    }
  }

  class MySQL extends DateBase with Log {
    println("我是MySQL")
  }
}
```



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317210325722.png" alt="image-20230317210325722" style="zoom: 33%;" />



![image-20230317210239547](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230317210239547.png)

##### super的本质

##### 判断对象的类型以及转换指定类型的对象isInstanceOf、asInstanceOf、ClassOf

```scala
class Person{
}
object Person {
    def main(args: Array[String]): Unit = {

        val person = new Person

        //（1）判断对象是否为某个类型的实例
        val bool: Boolean = person.isInstanceOf[Person]

        if ( bool ) {
            //（2）将对象转换为某个类型的实例
            val p1: Person = person.asInstanceOf[Person]
            println(p1)
        }

        //（3）获取类的信息
        val pClass: Class[Person] = classOf[Person]
        println(pClass)
    }
}
```

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319170225549.png" alt="image-20230319170225549" style="zoom: 80%;" />

##### 使用反射更改String类型（不可变）

![image-20230319181301325](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319181301325.png)



##### type给数据类型起别名

### 集合

#### 继承树

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319183425093.png" alt="image-20230319183425093" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319184712221.png" alt="image-20230319184712221" style="zoom:80%;" />

##### 不可变集合继承图scala.collection.**immutable**

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319185007121.png" alt="image-20230319185007121" style="zoom:80%;" />

##### 可变集合继承图scala.collection.**mutable**

![image-20230319185140614](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230319185140614.png)

#### Array（数组）

##### java中的数组与Scala中的数组

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320113057526.png" alt="image-20230320113057526" style="zoom:80%;" />

##### 不可变数组Array

###### 数组的基本语法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320103459208.png" alt="image-20230320103459208" style="zoom:80%;" />

###### 遍历数组

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320103621563.png" alt="image-20230320103621563" style="zoom:80%;" />

###### 匿名函数对象作为参数——至简原则

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320103858170.png" alt="image-20230320103858170" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320104043273.png" alt="image-20230320104043273" style="zoom:80%;" />

###### apply构建数组

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320110004987.png" alt="image-20230320110004987" style="zoom:80%;" />

###### Array其实是不可变数组&冒号运算符

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320110817983.png" alt="image-20230320110817983" style="zoom:80%;" />

运行结果：

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320111010256.png" alt="image-20230320111010256" style="zoom:80%;" />



###### 基本操作

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320112639619.png" alt="image-20230320112639619" style="zoom:80%;" />



##### 可变数组ArrayBuffer

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320114308248.png" alt="image-20230320114308248" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320114456897.png" alt="image-20230320114456897" style="zoom:80%;" />

##### 可变与不可变的转换

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320115044799.png" alt="image-20230320115044799" style="zoom:80%;" />



#### Seq（序列）

##### 不可变的序列List

List在Java中是接口，在scala中是class

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320132725928.png" alt="image-20230320132725928" style="zoom:80%;" />

###### 基本操作

List不是Scala的自定义类型，所以还是需要使用foreach来输出

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320133751115.png" alt="image-20230320133751115" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320133814858.png" alt="image-20230320133814858" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320142728701.png" alt="image-20230320142728701" style="zoom:80%;" />

##### 可变的序列ListBuffer

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320144622253.png" alt="image-20230320144622253" style="zoom:80%;" />

###### 互相转换

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320144701573.png" alt="image-20230320144701573" style="zoom:80%;" />

#### Set（集）

##### 不可变Set

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320145533801.png" alt="image-20230320145533801" style="zoom:80%;" />

##### 可变Set

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320151247652.png" alt="image-20230320151247652" style="zoom:80%;" />



#### Map（映射）

##### 不可变的map

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320154051457.png" alt="image-20230320154051457" style="zoom:80%;" />

##### 可变map

put和update没有区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320155004515.png" alt="image-20230320155004515" style="zoom:80%;" />

###### 按照key获取value

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320160919274.png" alt="image-20230320160919274" style="zoom:80%;" />

优化的方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320161138293.png" alt="image-20230320161138293" style="zoom:80%;" />

#### Tuple（元组）

函数对象传参也规定参数个数不得超过22

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320163615781.png" alt="image-20230320163615781" style="zoom:80%;" />

元组的简化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320164347281.png" alt="image-20230320164347281" style="zoom:80%;" />

##### 对偶元组&K/V键值对

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320165021531.png" alt="image-20230320165021531" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320165127732.png" alt="image-20230320165127732" style="zoom:80%;" />



#### 集合转换

与Map有关的转换实际上都是由Tuple作为中介

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320170104367.png" alt="image-20230320170104367" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320170118957.png" alt="image-20230320170118957" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320170200294.png" alt="image-20230320170200294" style="zoom:80%;" />

#### 方法

##### 常用方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320193043874.png" alt="image-20230320193043874" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320195635108.png" alt="image-20230320195635108" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230320195710516.png" alt="image-20230320195710516" style="zoom:80%;" />

##### sliding滑动窗口

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321100716298.png" alt="image-20230321100716298" style="zoom:80%;" />

##### 交集、并集、差集、拉链

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321110744104.png" alt="image-20230321110744104" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321111133957.png" alt="image-20230321111133957" style="zoom:80%;" />





##### 功能函数

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321113837031.png" alt="image-20230321113837031" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321113437522.png" alt="image-20230321113437522" style="zoom:80%;" />



###### map

Int => B；这里的B甚至可以是一个元组，详情看另一种方式实现wordcount

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321115014451.png" alt="image-20230321115014451" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321115136124.png" alt="image-20230321115136124" style="zoom:80%;" />

###### 扁平化flatten、flatMap

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321115843695.png" alt="image-20230321115843695" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230321120416817.png" alt="image-20230321120416817" style="zoom:80%;" />

###### filter

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230322154637979.png" alt="image-20230322154637979" style="zoom:80%;" />

###### groupBy

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230322155456339.png" alt="image-20230322155456339" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230322155527129.png" alt="image-20230322155527129" style="zoom:80%;" />

简化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230322155759693.png" alt="image-20230322155759693" style="zoom:80%;" />



###### mapValues

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328211248211.png" alt="image-20230328211248211" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328212711614.png" alt="image-20230328212711614" style="zoom:80%;" />

###### sortBy





<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328213736565.png" alt="image-20230328213736565" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328213539075.png" alt="image-20230328213539075" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328213828589.png" alt="image-20230328213828589" style="zoom:80%;" />

另一个sortBy案例



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328215424640.png" alt="image-20230328215424640" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328215637300.png" alt="image-20230328215637300" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328215806049.png" alt="image-20230328215806049" style="zoom:80%;" />

###### sortWith



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328222023727.png" alt="image-20230328222023727" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328221924000.png" alt="image-20230328221924000" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328221722946.png" alt="image-20230328221722946" style="zoom:80%;" />



######  	sortBy但是元组

依旧是上面的数据，但是更简化了

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328222954426.png" alt="image-20230328222954426" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328222900394.png" alt="image-20230328222900394" style="zoom:80%;" />

### WordCount

##### 实现思路

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328224826918.png" alt="image-20230328224826918" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328224710887.png" alt="image-20230328224710887" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328224727034.png" alt="image-20230328224727034" style="zoom:67%;" />

##### 实现

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328231600874.png" alt="image-20230328231600874" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328225720334.png" alt="image-20230328225720334" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328225813852.png" alt="image-20230328225813852" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328225952901.png" alt="image-20230328225952901" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328231026952.png" alt="image-20230328231026952" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328231431797.png" alt="image-20230328231431797" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328231457597.png" alt="image-20230328231457597" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230328231523788.png" alt="image-20230328231523788" style="zoom:80%;" />

##### 函数式编程优化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329124058745.png" alt="image-20230329124058745" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329124246300.png" alt="image-20230329124246300" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329124420920.png" alt="image-20230329124420920" style="zoom:80%;" />

再优化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329124508070.png" alt="image-20230329124508070" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329124629011.png" alt="image-20230329124629011" style="zoom:80%;" />



##### 另一种WordCount实现

数据源变成对偶元组map组成的list集合

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329144611596.png" alt="image-20230329144611596" style="zoom:80%;" />

第一步：扁平化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329145345678.png" alt="image-20230329145345678" style="zoom: 67%;" />

这一步的结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329145249891.png" alt="image-20230329145249891" style="zoom:67%;" />

使用group by

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329145318653.png" alt="image-20230329145318653" style="zoom: 80%;" />

结果：

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329145046480.png" alt="image-20230329145046480" style="zoom: 67%;" />

如何再进一步的演示

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329150843713.png" alt="image-20230329150843713" style="zoom: 80%;" />

实际应用

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329151039804.png" alt="image-20230329151039804" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329151115656.png" alt="image-20230329151115258" style="zoom:80%;" />

##### reduce

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329160613813.png" alt="image-20230329160613813" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329160532832.png" alt="image-20230329160532832" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329160553602.png" alt="image-20230329160553602" style="zoom:80%;" />

##### reduceLeft&reduceRight



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329162941023.png" alt="image-20230329162941023" style="zoom: 67%;" />

这个reduceRight是错的

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329162951424.png" alt="image-20230329162951424" style="zoom:67%;" />

正确的reduceRight

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329164318955.png" alt="image-20230329164318955" style="zoom:67%;" />

代码

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329163139092.png" alt="image-20230329163139092" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329163153027.png" alt="image-20230329163153027" style="zoom:80%;" />

如何正确区分

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329164152296.png" alt="image-20230329164152296" style="zoom:80%;" />



##### fold

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329165724105.png" alt="image-20230329165724105" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329165916704.png" alt="image-20230329165916704" style="zoom:80%;" />

##### foldLeft和foldRight

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329171304120.png" alt="image-20230329171304120" style="zoom:80%;" />

##### scan

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230329172038896.png" alt="image-20230329172038896" style="zoom:80%;" />





### 框架

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411113745946.png" alt="image-20230411113745946" style="zoom:50%;" />

Scala不适合工程开发，太强了，别人看不懂；（语法糖太多）工期不好评估

#### MVC架构：（Model View Controller）

主要针对B/S结构的服务

将代码强制分解成三个组成部分：模型，视图，控制器

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411115356925.png" alt="image-20230411115356925" style="zoom: 50%;" />

#### 三层架构：（Controller Service DAO）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411115915138.png" alt="image-20230411115915138" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411115753547.png" alt="image-20230411115753547" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411115830787.png" alt="image-20230411115830787" style="zoom: 50%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411150121965.png" alt="image-20230411150121965" style="zoom: 50%;" />

### 模式匹配

#### 简介

##### java中的模式匹配

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410125645924.png" alt="image-20230410125645924" style="zoom: 67%;" />

##### Scala中的模式匹配



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410125830928.png" alt="image-20230410125830928" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410125909752.png" alt="image-20230410125909752" style="zoom:67%;" />

##### Java与Scala模式匹配的区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410130607626.png" alt="image-20230410130607626" style="zoom:67%;" />

#### 匹配规则

##### 匹配常量

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410132535341.png" alt="image-20230410132535341" style="zoom:80%;" />

##### 匹配类型

使用something来代替_，因为后面想要使用这个变量

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410132446585.png" alt="image-20230410132446585" style="zoom:80%;" />

##### 匹配数组

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410133209711.png" alt="image-20230410133209711" style="zoom:67%;" />



##### 匹配列表

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410133705926.png" alt="image-20230410133705327" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410133759673.png" alt="image-20230410133759673" style="zoom:67%;" />

##### 匹配元组

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410134145033.png" alt="image-20230410134145033" style="zoom:67%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410134155121.png" alt="image-20230410134155121" style="zoom:67%;" />

##### 匹配对象

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410144403549.png" alt="image-20230410144403549" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410144451247.png" alt="image-20230410144451247" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410144732299.png" alt="image-20230410144732299" style="zoom:80%;" />

##### 样例类

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410154837733.png" alt="image-20230410154837733" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410145344996.png" alt="image-20230410145344996" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410145630868.png" alt="image-20230410145630868" style="zoom:80%;" />



#### 应用

##### 解构赋值

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410134921240.png" alt="image-20230410134921240" style="zoom:67%;" />

##### 少写点if判断

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410135254442.png" alt="image-20230410135254442" style="zoom:67%;" />

##### 简化匿名函数（不一定是代码量变少了，而是代码更容易理解了）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410140205570.png" alt="image-20230410140205570" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410140117719.png" alt="image-20230410140117719" style="zoom:80%;" />

##### WordCount中的应用

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410141853066.png" alt="image-20230410141853066" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410141943783.png" alt="image-20230410141943783" style="zoom:67%;" />

使用模式匹配后：

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410142233203.png" alt="image-20230410142233203" style="zoom:67%;" />

另一个小案例

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410142612342.png" alt="image-20230410142612342" style="zoom:67%;" />

#### 偏函数

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410151256887.png" alt="image-20230410151256887" style="zoom:80%;" />



### 其他补充

##### getOrElse方法

getOrElse大部分时候用于Map、option中**有可能存在空值或不存在要查找的值的情况**

- Map中的用法

```scala
myMap.getOrElse("key", "no key") 
//当"key"在Map中不存在时，则返回"no key"
//当"key"在Map中存在时，则返回key对应的value
```

- Option中的用法

```scala
object Test {
  def main(args: Array[String]) {
   val a:Option[Int] = Some(5)
   val b:Option[Int] = None

   println("a.getOrElse(0): " + a.getOrElse(0) )
   println("b.getOrElse(10): " + b.getOrElse(10) )
  }
}
运行结果
$ scalac Test.scala 
$ scala Test
a.getOrElse(0): 5
b.getOrElse(10): 10
```





# Spark

## Spark入门

Spark是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。

###### Spark VS Hadoop

hadoop

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330083126681.png" alt="image-20230330083126681" style="zoom:80%;" />

spark

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330083204310.png" alt="image-20230330083204310" style="zoom:80%;" />

##### spark核心模块

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330083528116.png" alt="image-20230330083528116" style="zoom: 50%;" />

Ø **Spark Core**

Spark Core中提供了Spark最基础与最核心的功能，Spark其他的功能如：Spark SQL，Spark Streaming，GraphX, MLlib都是在Spark Core的基础上进行扩展的

Ø **Spark SQL**

Spark SQL是Spark用来操作结构化数据的组件。通过Spark SQL，用户可以使用SQL或者Apache Hive版本的SQL方言（HQL）来查询数据。

Ø **Spark Streaming**

Spark Streaming是Spark平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API。

Ø **Spark MLlib**

MLlib是Spark提供的一个机器学习算法库。MLlib不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语。

Ø **Spark GraphX**

GraphX是Spark面向图计算提供的框架与算法库。

#####  WordCount

![image-20230330103103418](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330103103418.png)



使用reduece

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330103212534.png" alt="image-20230330103212534" style="zoom:80%;" />

使用spark封装的方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330103404228.png" alt="image-20230330103404228" style="zoom:80%;" />

##### 分布式的模式问题

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330155255121.png" alt="image-20230330155255121" style="zoom:33%;" />



Hadoop中既有元数据管理（中心节点）也有副本机制（主从节点）

Kafka只有副本broker机制

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330155540028.png" alt="image-20230330155540028" style="zoom:80%;" />

##### 提交流程

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330193931164.png" alt="image-20230330193931164" style="zoom: 67%;" />

## SparkCore&核心编程

### RDD

并行类似于Kafka

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330203223903.png" alt="image-20230330203223903" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330201856789.png" alt="image-20230330201856789" style="zoom:67%;" />

###### 装饰者设计模式

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230330204127159.png" alt="image-20230330204127159" style="zoom:67%;" />

RDD中不存储数据，只封装逻辑，只有调用collect后才会执行里面的逻辑

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331103243763.png" alt="image-20230331103243763" style="zoom:67%;" />

##### RDD创建

###### 从集合（内存）中创建

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331112702878.png" alt="image-20230331112702878" style="zoom:67%;" />

###### 从外部存储创建

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331113835492.png" alt="image-20230331113835492" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331113934783.png" alt="image-20230331113934783" style="zoom:80%;" />

### RDD并行度与分区

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331135831265.png" alt="image-20230331135831265" style="zoom: 67%;" />

第二个参数

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331140441928.png" alt="image-20230331140441928" style="zoom:80%;" />

###### 并行度

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331205533397.png" alt="image-20230331205533397" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331142020901.png" alt="image-20230331142020901" style="zoom:80%;" />

###### 读取内存集合数据的分区策略

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331145721270.png" alt="image-20230331145721270" style="zoom:67%;" />

源码

![image-20230331145806701](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331145806701.png)

运行逻辑

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331145822233.png" alt="image-20230331145822233" style="zoom:67%;" />

###### 读取文件的分区策略——hadoop

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331160054433.png" alt="image-20230331160054433" style="zoom:80%;" />

###### 磁盘文件流转进入分区的策略

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331162533762.png" alt="image-20230331162533762" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331162606436.png" alt="image-20230331162606436" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331162627192.png" alt="image-20230331162627192" style="zoom:67%;" />

### RDD算子

##### RDD算子入门

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331165259484.png" alt="image-20230331165259484" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331165221668.png" alt="image-20230331165221668" style="zoom:80%;" />

#### RDD转换算子——Value类型

##### map

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331172602193.png" alt="image-20230331172602193" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331173146854.png" alt="image-20230331173146854" style="zoom: 80%;" />

map原理

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331205900627.png" alt="image-20230331205900627" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331211147432.png" alt="image-20230331211147432" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331211246332.png" alt="image-20230331211246332" style="zoom: 50%;" />

3个RDD

![image-20230331210907642](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331210907642.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331210959140.png" alt="image-20230331210959140" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331211346913.png" alt="image-20230331211346913" style="zoom:67%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331211455621.png" alt="image-20230331211455621" style="zoom:67%;" />

##### mapPartitions

**![img](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/clip_image002.jpg)** 思考一个问题：map和mapPartitions的区别？

Ø **数据处理角度**

Map算子是分区内一个数据一个数据的执行，类似于串行操作。而mapPartitions算子是以分区为单位进行批处理操作。

就像是IO的时候加了一个buffer，减少了io次数，提升了效率

Ø **功能的角度**

Map算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变，所以**可以增加或减少数据(实现过滤)**

Ø **性能的角度**

Map算子因为类似于串行操作，所以性能比较低，而是mapPartitions算子类似于批处理，所以性能较高。但是mapPartitions算子**会长时间占用内存**，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用map操作。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230331214301329.png" alt="image-20230331214301329" style="zoom:67%;" />



小练习：获取分区最大值

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403145403590.png" alt="image-20230403145403590" style="zoom:80%;" />

###### java克隆浅复制

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403144524404.png" alt="image-20230403144524404" style="zoom: 67%;" />

打印结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403144613999.png" alt="image-20230403144613999" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403144655461.png" alt="image-20230403144655461" style="zoom:50%;" />

##### mapPartitionsWithIndex

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403150540905.png" alt="image-20230403150540905" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403150633074.png" alt="image-20230403150633074" style="zoom:80%;" />

##### flatMap

小功能：将List(List(1,2),3,List(4,5))进行扁平化操作

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403152024278.png" alt="image-20230403152024278" style="zoom:67%;" />

##### glom

将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变

![image-20230403152535029](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403152535029.png)

小功能：计算所有分区最大值求和（分区内取最大值，分区间最大值求和）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403153006586.png" alt="image-20230403153006586" style="zoom:67%;" />

##### groupBY

![image-20230403154900117](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403154900117.png)

###### shuffle

完全依靠内存的问题：

- 等待
- 分区浪费

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403161257362.png" alt="image-20230403161257362" style="zoom:67%;" />

shuffle操作不允许在内存中等待，必须落盘，但是又会影响分区间不会互相影响的特性

解决方法：

- shuffle会将完整的计算过程一分为二，形成两个阶段，一个阶段用于写数据，一个阶段用于读数据
- 写数据阶段没有完成，读数据阶段不能执行
- shuffle操作可以更改分区

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403162544295.png" alt="image-20230403162544295" style="zoom:67%;" />

###### 小练习

将List("Hello", "hive", "hbase", "Hadoop")根据单词首写字母进行分组。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403170625337.png" alt="image-20230403170625337" style="zoom:80%;" />

从服务器日志数据apache.log中获取每个时间段访问量

![image-20230403171134527](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403171134527.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403171358687.png" alt="image-20230403171358687" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403171230125.png" alt="image-20230403171230125" style="zoom:67%;" />

##### filter

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403204715717.png" alt="image-20230403204715717" style="zoom: 67%;" />

##### sample

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403215953430.png" alt="image-20230403215953430" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403215719113.png" alt="image-20230403215719113" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230403215615820.png" alt="image-20230403215615820" style="zoom:67%;" />

##### distinct

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404112721086.png" alt="image-20230404112721086" style="zoom: 67%;" />

##### coalesce

缩减分区使用的是首选分区，不管数据的多少，只会把同分区的task里的数据合并，因此需要用到shuffle

![image-20230404115115897](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404115115897.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404114915679.png" alt="image-20230404114915679" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404115232926.png" alt="image-20230404115232926" style="zoom: 80%;" />

##### repartition

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404121504260.png" alt="image-20230404121504260" style="zoom:67%;" />

##### sortBy

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404122107940.png" alt="image-20230404122107940" style="zoom:80%;" />

#### RDD转换算子——双Value类型

##### intersection交集、union并集、subtract差集

- 两个rdd数据类型必须一致

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404122645780.png" alt="image-20230404122645780" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404122659301.png" alt="image-20230404122659301" style="zoom:67%;" />

##### zip拉链

- 数据类型可以不一样
- 分区数必须一样
- 分区内的元素个数必须一样（与scala相区别）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404123619716.png" alt="image-20230404123619716" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404123634424.png" alt="image-20230404123634424" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404123659033.png" alt="image-20230404123659033" style="zoom:67%;" />

#### RDD转换算子——Key-Value类型

##### partitionBy

将数据按照指定Partitioner重新进行分区。Spark默认的分区器是HashPartitioner

KV隐式转换

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404144609248.png" alt="image-20230404144609248" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404144645335.png" alt="image-20230404144645335" style="zoom: 67%;" />

![image-20230404144943799](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404144943799.png)

![image-20230404145015378](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404145015378.png)

##### reduceByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404145323040.png" alt="image-20230404145323040" style="zoom:67%;" />

##### groupByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404151004461.png" alt="image-20230404151004461" style="zoom:67%;" />

###### groupBy和groupByKey的区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404151204596.png" alt="image-20230404151204596" style="zoom:80%;" />

###### combine预聚合——reduceByKey和groupByKey怎么选

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404153300818.png" alt="image-20230404153300818" style="zoom: 80%;" />

groupByKey：

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404153459211.png" alt="image-20230404153459211" style="zoom:80%;" />

reduceByKey：

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404153653221.png" alt="image-20230404153653221" style="zoom:80%;" />

##### aggregateByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404164654447.png" alt="image-20230404164654447" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404165656459.png" alt="image-20230404165656459" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404165801450.png" alt="image-20230404165801450" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404172012743.png" alt="image-20230404172012743" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404172113087.png" alt="image-20230404172113087" style="zoom: 50%;" />

###### 实现wordcount

![image-20230404171137944](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404171137944.png)

##### foldByKey

##### combineByKey

![image-20230404172858795](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404172858795.png)

![image-20230404210140973](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404210140973.png)



![image-20230404205030243](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404205030243.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404173932294.png" alt="image-20230404173932294" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404173942059.png" alt="image-20230404173942059" style="zoom:80%;" />

###### WordCount

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404210709574.png" alt="image-20230404210709574" style="zoom:67%;" />

源码分析：都有预聚合功能，groupByKey没有

![image-20230404212129031](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230404212129031.png)

##### sortByKey

如果将自定义的类作为key，则需要混入ordered特质。重写其方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405113045714.png" alt="image-20230405113045714" style="zoom:67%;" />

##### join

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405113453695.png" alt="image-20230405113453695" style="zoom:67%;" />

没有间接依赖

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405113524701.png" alt="image-20230405113524701" style="zoom:67%;" />

##### leftOuterJoin



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405114256699.png" alt="image-20230405114256699" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405115146769.png" alt="image-20230405115146769" style="zoom: 67%;" />

Some和None是option的两个值

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405115335544.png" alt="image-20230405115335544" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405115353334.png" alt="image-20230405115353334" style="zoom:67%;" />

##### cogroup

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405120546589.png" alt="image-20230405120546589" style="zoom:67%;" />

![image-20230405120603507](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405120603507.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405120618688.png" alt="image-20230405120618688" style="zoom:67%;" />

可以把多个（至多4个）RDD组合在一起

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405120654457.png" alt="image-20230405120654457" style="zoom:67%;" />

#### 案例实操

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405122354647.png" alt="image-20230405122354647" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405122336979.png" alt="image-20230405122336979" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405122115781.png" alt="image-20230405122115781" style="zoom: 67%;" />

###### reduceByKey代码实现

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405142229261.png" alt="image-20230405142229261" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405142705881.png" alt="image-20230405142705881" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405142804224.png" alt="image-20230405142804224" style="zoom:80%;" />

运行结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405142831610.png" alt="image-20230405142831610" style="zoom:67%;" />

###### groupByKey代码实现：

建议使用第一种使用reduceByKey的，先预聚合，而不是先做分组，可以减少数据量。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405145101331.png" alt="image-20230405145101331" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405145203421.png" alt="image-20230405145203421" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405145220630.png" alt="image-20230405145220630" style="zoom:67%;" />

###### 优化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405155153853.png" alt="image-20230405155153853" style="zoom:67%;" />

同一个List下有非常多的元素，在内存里进行排序爆内存。改成

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405155106271.png" alt="image-20230405155106271" style="zoom:67%;" />

#### RDD行动算子

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230405161121795.png" alt="image-20230405161121795" style="zoom:80%;" />

##### reduce、collect、count、first、take、takeOrdered

collect采集数据量特别大的数据存在问题

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406114934012.png" alt="image-20230406114934012" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406114308396.png" alt="image-20230406114308396" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406114710801.png" alt="image-20230406114710801" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406114749429.png" alt="image-20230406114749429" style="zoom:67%;" />

##### aggregate、fold

与aggregateByKey的就算方式不一样

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406115957088.png" alt="image-20230406115957088" style="zoom:67%;" />

##### countByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406121025903.png" alt="image-20230406121025903" style="zoom:67%;" />



##### countByValue

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406121737049.png" alt="image-20230406121737049" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406121814439.png" alt="image-20230406121814439" style="zoom:67%;" />

##### save相关算子

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406122417764.png" alt="image-20230406122417764" style="zoom:67%;" />

##### foreach

rdd算子和Scala集合方法的区别

collect能够按照分区号来采集，所以先使用collect再使用foreach永远得到原来的顺序的序列。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406123108392.png" alt="image-20230406123108392" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406123120998.png" alt="image-20230406123120998" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406123239990.png" alt="image-20230406123239990" style="zoom:67%;" />

#### RDD序列化

##### 闭包检测

![image-20230406152753717](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406152753717.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406150907782.png" alt="image-20230406150907782" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406151039287.png" alt="image-20230406151039287" style="zoom:67%;" />

![image-20230406150930438](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406150930438.png)



##### Kryo序列化框架

#### RDD依赖关系

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406163215343.png" alt="image-20230406163215343" style="zoom: 67%;" />

##### 血缘关系

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165633817.png" alt="image-20230406165633817" style="zoom:80%;" />

打印orkCount的血缘关系

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165142312.png" alt="image-20230406165142312" style="zoom:67%;" />

![image-20230406165255257](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165255257.png)

![image-20230406165334265](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165334265.png)

![image-20230406165422751](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165422751.png)

##### 依赖关系

其实就是两个相邻RDD之间的关系

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406165918990.png" alt="image-20230406165918990" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406171450599.png" alt="image-20230406171450599" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406171119316.png" alt="image-20230406171119316" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406171155225.png" alt="image-20230406171155225" style="zoom:67%;" />

这也是窄依赖

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406171259553.png" alt="image-20230406171259553" style="zoom:67%;" />

##### RDD阶段划分



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406211123665.png" alt="image-20230406211123665" style="zoom:67%;" />

#### RDD持久化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406220134249.png" alt="image-20230406220134249" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406220249035.png" alt="image-20230406220249035" style="zoom:67%;" />

###### cache设置持久化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406220641910.png" alt="image-20230406220641910" style="zoom:67%;" />

- cache操作会增加血缘关系，不改变原有的血缘关系

![image-20230406221648723](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406221648723.png)



![image-20230406221631338](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406221631338.png)

###### checkpoint设置持久化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406220947543.png" alt="image-20230406220947543" style="zoom:67%;" />

 设置检查点可以切断血缘关系

![image-20230406221256776](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406221256776.png)

设置检查点后

![image-20230406221304301](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406221304301.png)

###### cache和checkpoint往往同时使用

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406222223172.png" alt="image-20230406222223172" style="zoom: 80%;" />

###### 缓存和检查点的区别

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230406222357949.png" alt="image-20230406222357949" style="zoom:80%;" />

#### RDD分区器

##### 自定义分区器（2+2）

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407112849344.png" alt="image-20230407112849344" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407112954022.png" alt="image-20230407112954022" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407112928077.png" alt="image-20230407112928077" style="zoom:67%;" />

###### 相同自定义分区器如何避免重复shuffle

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407121927964.png" alt="image-20230407121927964" style="zoom:80%;" />

判断传进来的分区器和自身的分区器是否是同一个，且分区数量一样

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407121450814.png" alt="image-20230407121450814" style="zoom:80%;" />

###### 重写equals方法

因此自定义分区器往往要重写equals方法

![image-20230407121953214](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407121953214.png)

### ACC累加器

##### 累加器入门

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410214649760.png" alt="image-20230410214649760" style="zoom:67%;" />

不使用累加器结果为0，类似于两数交换

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407143831650.png" alt="image-20230407143831650" style="zoom: 67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407143427258.png" alt="image-20230407143427258" style="zoom:67%;" />

使用累加器结果正常

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407143913174.png" alt="image-20230407143913174" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407144023865.png" alt="image-20230407144023865" style="zoom:67%;" />

##### 自定义累加器

###### 自定义累加器实现WordCount

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407150629733.png" alt="image-20230407150629733" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407150656311.png" alt="image-20230407150656311" style="zoom:67%;" />

重写方法

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407161814632.png" alt="image-20230407161814632" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407161716202.png" alt="image-20230407161716202" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407161913516.png" alt="image-20230407161913516" style="zoom:67%;" />

### BC广播变量

join的缺点

- 笛卡尔积
- shuffle

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407170144532.png" alt="image-20230407170144532" style="zoom:67%;" />

使用map来代替join

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407170218427.png" alt="image-20230407170218427" style="zoom:67%;" />

出现的问题：每个分区有一个task，每个task都会传一个map集合进入Executor，造成**数据冗余**

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407170258238.png" alt="image-20230407170258238" style="zoom:67%;" />

解决方法：使用广播变量

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407170430782.png" alt="image-20230407170430782" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230407170541762.png" alt="image-20230407170541762" style="zoom:67%;" />

### 案例实操

#### 需求一：Top10热门品类

##### 实现方案一

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410164514397.png" alt="image-20230410164514397" style="zoom: 67%;" />

统计品类的点击数量

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410164953827.png" alt="image-20230410164953827" style="zoom: 67%;" />

统计品类的下单、支付数量

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410165219101.png" alt="image-20230410165219101" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410165346519.png" alt="image-20230410165346519" style="zoom:67%;" />

转换成元组进行排序

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410172512365.png" alt="image-20230410172512365" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410172703036.png" alt="image-20230410172703036" style="zoom:67%;" />

##### 实现方案一优化

###### 重复读取数据——持久化RDD

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410210855834.png" alt="image-20230410210855834" style="zoom: 80%;" />

###### cogroup的笛卡尔积问题——使用union然后再reduceByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410211158013.png" alt="image-20230410211158013" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410211304351.png" alt="image-20230410211304351" style="zoom:67%;" />

这里sortBy要加一个false参数

##### 实现方案二

###### reduceByKey太多——从源头改造数据，只使用一次reduceByKey

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410212935574.png" alt="image-20230410212935574" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410213445081.png" alt="image-20230410213445081" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410213621409.png" alt="image-20230410213621409" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230410213724327.png" alt="image-20230410213724327" style="zoom:67%;" />

##### 实现方案三——使用累加器

```scala
package com.atguigu.bigdata.spark.req

import org.apache.spark.util.AccumulatorV2
import org.apache.spark.{SparkConf, SparkContext}

import scala.collection.mutable

object Spark01_Req_HotCategoryTop10_3 {

    def main(args: Array[String]): Unit = {

        val conf = new SparkConf().setMaster("local[*]").setAppName("HotCategoryTop10")
        val sc = new SparkContext(conf)

        val fileDatas = sc.textFile("data/user_visit_action.txt")

        // 创建累加器对象
        val acc = new HotCategoryAccumulator()
        // 注册累加器
        sc.register(acc, "HotCategory")

        fileDatas.foreach(
            data => {
                val datas = data.split("_")
                if ( datas(6) != "-1" ) {
                    // 点击的场合
                    acc.add( (datas(6), "click") )
                } else if ( datas(8) != "null" ) {
                    // 下单的场合
                    val id = datas(8)
                    val ids = id.split(",")
                    ids.foreach(
                        id => {
                            acc.add( (id, "order") )
                        }
                    )
                } else if ( datas(10) != "null" ) {
                    // 支付的场合
                    val id = datas(10)
                    val ids = id.split(",")
                    ids.foreach(
                        id => {
                            acc.add( (id, "pay") )
                        }
                    )
                }
            }
        )

        // TODO 获取累加器的结果
        val resultMap: mutable.Map[String, HotCategoryCount] = acc.value
        val top10 = resultMap.map(_._2).toList.sortWith(
            (left, right) => {
                if ( left.clickCnt > right.clickCnt ) {
                    true
                } else if ( left.clickCnt == right.clickCnt ) {
                    if ( left.orderCnt > right.orderCnt ) {
                        true
                    } else if ( left.orderCnt == right.orderCnt ) {
                        left.payCnt > right.payCnt
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
        ).take(10)

        top10.foreach(println)

        sc.stop()

    }
    case class HotCategoryCount( cid:String, var clickCnt : Int, var orderCnt : Int, var payCnt : Int )
    // TODO 自定义热门点击累加器
    //  1. 继承AccumulatorV2
    //  2. 定义泛型
    //     IN : (品类ID，行为类型)
    //     OUT : Map[品类ID, HotCategoryCount]
    //  3. 重写方法 （3 + 3）
    class HotCategoryAccumulator extends AccumulatorV2[(String, String), mutable.Map[String, HotCategoryCount]]{

        private val map = mutable.Map[String, HotCategoryCount]()

        override def isZero: Boolean = {
            map.isEmpty
        }

        override def copy(): AccumulatorV2[(String, String), mutable.Map[String, HotCategoryCount]] = {
            new HotCategoryAccumulator()
        }

        override def reset(): Unit = {
            map.clear()
        }

        override def add(v: (String, String)): Unit = {
            val (cid, actionType) = v
            val hcc: HotCategoryCount = map.getOrElse(cid, HotCategoryCount(cid, 0, 0, 0))
            actionType match {
                case "click" => hcc.clickCnt += 1
                case "order" => hcc.orderCnt += 1
                case "pay" => hcc.payCnt += 1
            }
            map.update(cid, hcc)
        }

        override def merge(other: AccumulatorV2[(String, String), mutable.Map[String, HotCategoryCount]]): Unit = {
            other.value.foreach {
                case ( cid, otherHCC ) => {
                    val thisHCC: HotCategoryCount = map.getOrElse(cid, HotCategoryCount(cid, 0, 0, 0))
                    thisHCC.clickCnt += otherHCC.clickCnt
                    thisHCC.orderCnt += otherHCC.orderCnt
                    thisHCC.payCnt += otherHCC.payCnt
                    map.update(cid, thisHCC)
                }
            }
        }

        override def value: mutable.Map[String, HotCategoryCount] = {
            map
        }
    }
}
```

#### 需求二：Top10热门品类中每个品类的Top10活跃Session统计

##### 框架化

```scala
package com.atguigu.bigdata.spark.summer.bean

//用户访问动作表
case class UserVisitAction(
  date: String,//用户点击行为的日期
  user_id: Long,//用户的ID
  session_id: String,//Session的ID
  page_id: Long,//某个页面的ID
  action_time: String,//动作的时间点
  search_keyword: String,//用户搜索的关键词
  click_category_id: Long,//某一个商品品类的ID
  click_product_id: Long,//某一个商品的ID
  order_category_ids: String,//一次订单中所有品类的ID集合
  order_product_ids: String,//一次订单中所有商品的ID集合
  pay_category_ids: String,//一次支付中所有品类的ID集合
  pay_product_ids: String,//一次支付中所有商品的ID集合
  city_id: Long//城市 id
)
```

```scala
package com.atguigu.bigdata.spark.summer.service

import com.atguigu.bigdata.spark.summer.bean.UserVisitAction
import com.atguigu.bigdata.spark.summer.common.TService
import com.atguigu.bigdata.spark.summer.dao.{HotCategoryTop10Dao, HotCategoryTop10SessionDao}
import org.apache.spark.rdd.RDD

class HotCategoryTop10SessionService extends TService {

    private val hotCategoryTop10SessionDao = new HotCategoryTop10SessionDao

    override def analysis( data : Any ) = {
        val topIds: Array[String] = data.asInstanceOf[Array[String]]

        val fileDatas = hotCategoryTop10SessionDao.readFileBySpark("data/user_visit_action.txt")
//将数据导入样例类的集合
        val actionDatas = fileDatas.map(
            data => {
                val datas = data.split("_")
                UserVisitAction(
                    datas(0),
                    datas(1).toLong,
                    datas(2),
                    datas(3).toLong,
                    datas(4),
                    datas(5),
                    datas(6).toLong,
                    datas(7).toLong,
                    datas(8),
                    datas(9),
                    datas(10),
                    datas(11),
                    datas(12).toLong
                )
            }
        )
//只取商品id点击数量前10内的
        val clickDatas = actionDatas.filter {
            data => {
                if ( data.click_category_id != -1 ) {
                    topIds.contains(data.click_category_id.toString)
                } else {
                    false
                }
            }
        }
//先统计再分组，减少shuffle数据量
        val reduceDatas = clickDatas.map(
            data => {
                (( data.click_category_id, data.session_id ), 1)
            }
        ).reduceByKey(_+_)
//分组
        val groupDatas: RDD[(Long, Iterable[(String, Int)])] = reduceDatas.map {
            case ((cid, sid), cnt) => {
                (cid, (sid, cnt))
            }
        }.groupByKey()
//排序取前10
        groupDatas.mapValues(
            iter => {
                iter.toList.sortBy(_._2)(Ordering.Int.reverse).take(10)
            }
        ).collect()
    }
}
```

#### 需求3：页面单跳转换率统计

出现采集的时间没有顺序的原因

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411202129893.png" alt="image-20230411202129893" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411202229984.png" alt="image-20230411202229984" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411202401258.png" alt="image-20230411202401258" style="zoom: 50%;" />

处理流程

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411202532725.png" alt="image-20230411202532725" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230411202837866.png" alt="image-20230411202837866" style="zoom: 33%;" />

## Spark内核

#### 痛苦的源码

总之源码不必看，记住这张图就行

![](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412120516700.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412121418722.png" alt="image-20230412121418722" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412121112341.png" alt="image-20230412121112341" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412121303956.png" alt="image-20230412121303956" style="zoom: 67%;" />

##### Spark提交流程

![image-20230414104255503](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414104255503.png)



RPC协议的主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样





## SparkSQL

### SparkSQL概述

Hive on Spark & Spark on Hive

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412144345491.png" alt="image-20230412144345491" style="zoom:67%;" />



### SparkSQL编程



DataFrame

DataSet

创建sparksession

![image-20230412152541477](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412152541477.png)

#### 创建DataFrame

##### toDF方法创建

- 需要使用隐式转换
- 使用样例类、tuple、rdd

![image-20230412160354133](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412160354133.png)

![image-20230412161019057](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412161019057.png)

df.printSchema()的结果

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412164216473.png" alt="image-20230412164216473" style="zoom:80%;" />

##### 读取文件创建

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412161618029.png" alt="image-20230412161618029" style="zoom:80%;" />

#####  通过其他DataFrame衍生

类似于RDD算子转换

![image-20230412162340569](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412162340569.png)

##### CreateDataFrame创建

![image-20230412163807769](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412163807769.png)

#### 创建DataSet

![image-20230412165238838](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412165238838.png)

##### 通过toDS方法创建

![image-20230412165216626](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412165216626.png)

##### 读取文件创建

只能读取文本文件

![image-20230412165848011](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412165848011.png)

##### 通过其他DataFrame衍生

![image-20230412171113555](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412171113555.png)

##### CreateDataSet创建

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412171509688.png" alt="image-20230412171509688" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412171447668.png" alt="image-20230412171447668" style="zoom:80%;" />

#### SparkSQL编程方式

##### 命令式：使用方法操作数据

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412184409210.png" alt="image-20230412184409210" style="zoom: 80%;" />



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412184853355.png" alt="image-20230412184853355" style="zoom:80%;" />



##### 声明式：使用SQL操作数据【常用】

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412185626793.png" alt="image-20230412185626793" style="zoom: 80%;" />

实现wordcount

![image-20230412190123468](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412190123468.png)

#### 三者转换



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413114544774.png" alt="image-20230413114544774" style="zoom:80%;" />

![image-20230412192712450](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412192712450.png)

DF转换成RDD,直接.rdd即可,但是要注意转换出来的rdd数据类型会变成Row

如果想获取到row里面的数据,直接row.get(索引)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412193030895.png" alt="image-20230412193030895" style="zoom:80%;" />



这里读取文件将DataFrame变成DataSet的时候，顺序可能出现问题。

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412194755776.png" alt="image-20230412194755776" style="zoom:80%;" />

![image-20230412195823022](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412195823022.png)

#### 用户自定义函数

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412201913773.png" alt="image-20230412201913773" style="zoom:80%;" />

##### UDF

- 函数定义完成后，需要将函数注册到SparkSession中
- 定义的如果是方法，则需要使用下划线转换成函数后注册

![image-20230412205804172](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412205804172.png)

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412210128930.png" alt="image-20230412210128930" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230412210259657.png" alt="image-20230412210259657" style="zoom:80%;" />

##### UDAF

User Defined Aggregete Function

###### 弱类型定义UDAF

看懂了day08的视频就行

###### 强类型定义UDAF

![image-20230413151418859](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413151418859.png)

![image-20230413151743400](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413151743400.png)

![image-20230413152046466](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413152046466.png)

###### 使用UDAF

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413152446077.png" alt="image-20230413152446077" style="zoom:80%;" />

![image-20230413152710711](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413152710711.png)

### SparkSQL的数据加载与保存

##### 读取文件

方式二是对方式一的封装

![image-20230413154039441](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413154039441.png)

![image-20230413160804652](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230413160804652.png)

##### 读取MySQL文件

# 离线数仓

##### 电商系统表结构

（位于采集项目文档02_1.2.3）

所有表的详情位于离线数仓项目文档2业务数据采集平台v5.0_2.1

电商业务表

![image-20230414092257734](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414092257734.png)

后台管理系统表

![image-20230414092359148](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414092359148.png)

平台属性表（base_attr_info）：

指的是点进去一个三级分类，里面有可选的属性，因此关联一个三级分类

一行代表一个属性，如图就有6行

![image-20230414095314876](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414095314876.png)

## 数仓建模方法论

### ER模型

#### 三范式

函数依赖

![image-20230414113421335](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414113421335.png)

##### 第一范式

![image-20230414133524518](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414133524518.png)

##### 第二范式

![image-20230414133723849](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414133723849.png)

##### 第三范式

![image-20230414133925221](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230414133925221.png)

这种建模方法的出发点是整合数据，其目的是将整个企业的数据进行组合和合并，并进行规范处理，减少数据冗余性，保证数据的一致性。这种模型并不适合直接用于分析统计。（join太多，shuffle太多）

### 维度模型

#### 事实表

##### 事务事实表

##### 周期快照事实表

##### 累积快照事实表

#### 维度表

### 数仓开发之ODS层

##### SerDe是什么

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230419113228424.png" alt="image-20230419113228424" style="zoom:80%;" />

在hive中建表实际上底层做了什么

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230419113707819.png" alt="image-20230419113707819" style="zoom: 80%;" />

查看hdfs上数据

hadoop fs -cat /origin_data/gmall/db/cart_info_inc/2020-06-14/* | zcat







![image-20230419185258122](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230419185258122.png)





![image-20230419185324809](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230419185324809.png)





![image-20230419185350189](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230419185350189.png)

CTE公共表表达式

修复元数据与hdfs文件的映射关系

![image-20230420114626572](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230420114626572.png)

动态分区的非严格模式

```
set hive.exec.dynamic.partition.mode=nonstrict;
```

### DIM层

### DWD层

##### 交易域加购事务事实表

数仓上线之前，业务数据库里面就已经有了许多加购信息，因此需要将之前的数据按照日期分区存储到不同的分区表中。然后再增量监听新的加购数据。



<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421114842952.png" alt="image-20230421114842952" style="zoom:80%;" />

所以将装载分为首日装载和每日装载。

**首日装载：**

- 使用的是ods_cart_info_inc这张增量表，而不是ods_cart_info_full这张全量表，因为在使用Maxwell做增量同步时，首日是全量同步，后面才是增量同步。（好像我这么理解的话，也可以使用ods_cart_info_full这张表，只是装载逻辑变了，因为dataX同步的数据格式和Maxwell不同结构体）

- 动态分区需要指定分区字段，使用create_time的格式化

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421142006308.png" alt="image-20230421142006308" style="zoom:67%;" />

**每日装载：**

难点在于判断哪些是insert加购，哪些是update加购

![image-20230421141716817](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421141716817.png)

##### 交易域下单事务事实表

Maxwell的首日全量type类型是bootstrap-insert

每日增量是insert、update、delete基于binlog

##### 交易域取消订单事务事实表

# Git

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421152423999.png" alt="image-20230421152423999" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421154240571.png" alt="image-20230421154240571" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421154303169.png" alt="image-20230421154303169" style="zoom:33%;" />

![image-20230421160744398](https://cdn.jsdelivr.net/gh/ECNU-Howie/Images/img/image-20230421160744398.png)
